'''
マップの行数 H と列数 W ,障害物を # ,移動可能な場所を . で表した H 行 W 列のマップ S_1 ... S_H が与えられます。
続けて現在の座標 sy , sx ,現在向いている方角 d ,１マス移動する方向 m が与えられるので、移動が可能かどうかを判定してください。
移動可能であるということは、以下の図の通り __「移動先が障害物でない　かつ　移動先がマップの範囲外でない」__ ということを意味します。
なお、マスの座標系は左上端のマスの座標を ( y , x ) = ( 0 , 0 ) とし、
下方向が y 座標の正の向き、右方向が x 座標の正の向きとします。
'''
H, W, sy, sx, d, m = input().split()

H = int(H)
W = int(W)
# 上下左右に1マスずつ広いマップを作るため、初期位置にプラスする

sy = int(sy)+1
sx = int(sx)+1

# 上下左右に1マスずつ広いマップを作るため、初期位置にプラスする
map = [['#'] * (W+2) for i in range(H+2)]

# 入力値を代入する。移動可能なマスは.になり上下左右の端に#の壁ができる
for h in range(H):
    line = input()
    for w in range(W):
        map[h+1][w+1] = line[w]

# ある向きで前に進んだ移動に対応するマップを作成
moveX = [0, 1, 0, -1]
moveY = [-1, 0, 1, 0]

# 方角と配列の値をマッピング
dir = {'N':0, 'E':1, 'S':2, 'W':3}

# 北を向いている時に右に進むのは東に向かって進むのと同義なので
# 右ならdirを+1, 左ならdirを-1するする
move = {'R':1, 'L':-1}
md = dir[d] + move[m]

# 配列の範囲を超えないための処理
md = 0 if md == 4 else md 
md = 3 if md < 0 else md 

if map[sy+moveY[md]][sx+moveX[md]] == '.':
    print('Yes')
else:
    print('No')